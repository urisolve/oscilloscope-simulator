//* This file contains the functions that create the graphs for the oscilloscope

//? ------------------- Data Modification before drawing ------------------- //
function updateChart1(){
    //This function will be used to update the chart with the new data
    if(horizontalSweep == 0){ // Main Mode
        if(CH1inputFlag == 1){
            CH1Data = JSON.parse(JSON.stringify(CH1BaseData));
            CH1Data.forEach(d => {
                let amplitude = parseFloat(d.Amplitude);
                if(CH1ChangableWave == 1){ // Signal generated by the Signal Generator
                    amplitude = amplitude * amplitudeValueCH1;
                    if(couplingValueCH1 == 2){ amplitude = amplitude + offsetValueCH1; } // In case of DC coupling
                }
                if(CH1CalibrationWave == 1){
                    if(couplingValueCH1 == 2){ amplitude = amplitude + 1; }
                }
                if(CH1ExtSignal == 1){
                    if(couplingValueCH1 == 0){ amplitude = amplitude - CH1ExtVavg; }
                }
                if(couplingValueCH1 == 0 || couplingValueCH1 == 2){ d.Amplitude = amplitude; } // AC or DC
                if(probeValueCH1 == 1){ d.Amplitude = d.Amplitude * 10; } // x10 Probe
                else if(probeValueCH1 == 2){ d.Amplitude = d.Amplitude * 100; }  // x100 Probe
                if(CH1ChangableWave == 1){
                    let time = parseFloat(d.Time);
                    d.Time = time * 1000/frequencyCH1_Value; 
                }
                if(triggerSlopeValue == 1){ d.Amplitude = -d.Amplitude;}// Falling Edge
            });
//! --------- TESTAR --------
// TODO - Em princípio funciona mas é preciso testar de mais formas diferentes e adaptar para o CH2
            let CH1DataTemp = JSON.parse(JSON.stringify(CH1Data));
            CH1DataTemp.forEach(d => {
                if(trigger.slope == 1){ d.Amplitude = -d.Amplitude;}// Falling Edge
                if(invertValueCH1 == 1){ d.Amplitude = -d.Amplitude; } // Invert
            });
//! -------------------------
            if(couplingValueCH1 == 1){
                showGraph1(dcSignal);
            } // GND
            else{
                showGraph1(CH1DataTemp);
            };
            measureCalculationCH1();
            if(measureFlag == 1){ measureMenu1(); }
            if(measureAllCH1Flag == 1){ measureAllCH1(); }

        }
        else if(CH1inputFlag == 0){ 
            showGraph1(dcSignal);
        }
        if(mathDataFlag == 1){ updateChart3(); }
    }
    else if(horizontalSweep == 4){ // XY Mode
        updateChartXY();
    }
    // TODO - Trigger frequency possible solution
    if(trigger.source == 0){
        $("#ch1-signal-frequency").css("display", "block");
        $("#ch1-signal-frequency").text(frequencyCH1 + "Hz");
        $("#ch2-signal-frequency").css("display", "none");
    }
    else if(trigger.source == 1){
        $("#ch1-signal-frequency").css("display", "none");
        $("#ch2-signal-frequency").css("display", "block");
        $("#ch2-signal-frequency").text(frequencyCH2 + "Hz");
    }
}
function updateChart2(){
    if(horizontalSweep == 0){ // Main Mode
        if(CH2inputFlag == 1){
            CH2Data = JSON.parse(JSON.stringify(CH2BaseData));
            CH2Data.forEach(d => {
                let amplitude = parseFloat(d.Amplitude);
                amplitudeCH2_Value = amplitude;
                if(CH2ChangableWave == 1 ){ // Signal generated by the Signal Generator
                    amplitude = amplitude * amplitudeValueCH2;
                    if(couplingValueCH2 == 2){ amplitude = amplitude + offsetValueCH2; } // In case of DC coupling
                }
                if(CH2CalibrationWave == 1){
                    if(couplingValueCH2 == 2){ amplitude = amplitude + 1; }
                }
                if(CH2ExtSignal == 1){
                    if(couplingValueCH2 == 0){ amplitude = amplitude - CH2ExtVavg; }
                }
                if(couplingValueCH2 == 0 || couplingValueCH2 == 2){ d.Amplitude = amplitude; } // AC or DC
                if(couplingValueCH2 == 1){d.Amplitude = 0} // GND
                if(invertValueCH2 == 1){ d.Amplitude = -d.Amplitude; } // Invert
                if(probeValueCH2 == 1){ d.Amplitude = d.Amplitude * 10; } // x10 Probe
                else if(probeValueCH2 == 2){ d.Amplitude = d.Amplitude * 100; }  // x100 Probe
                if(CH2ChangableWave == 1){
                    let time = parseFloat(d.Time);
                    d.Time = time * 1000/frequencyCH2_Value; 
                }
            });
            showGraph2(CH2Data);
            measureCalculationCH2();
            if(measureFlag == 1){ measureMenu1(); }
            if(measureAllCH2Flag == 1){ measureAllCH2(); }
        }
        else if(CH2inputFlag == 0){ showGraph2(dcSignal); }
        if(mathDataFlag == 1){ updateChart3(); }
    }
    else if(horizontalSweep == 4){ // XY Mode
        updateChartXY();
    }
    // TODO - Trigger frequency possible solution
    if(trigger.source == 0){
        $("#ch1-signal-frequency").css("display", "block");
        $("#ch1-signal-frequency").text(frequencyCH1 + "Hz");
        $("#ch2-signal-frequency").css("display", "none");
    }
    else if(trigger.source == 1){
        $("#ch1-signal-frequency").css("display", "none");
        $("#ch2-signal-frequency").css("display", "block");
        $("#ch2-signal-frequency").text(frequencyCH2 + "Hz");
    }
}
function updateChart3(){ 
    let frequencyCH1Value = parseFloat(frequencyCH1_Value);
    let frequencyCH2Value = parseFloat(frequencyCH2_Value);
    // TODO - A solução para o problema é fazer o minimo multiplo comum
        let step, last;
        if(frequencyCH1Value > frequencyCH2Value && frequencyCH1Value < 5 * frequencyCH2Value){
            CH1Data.forEach((d, i) => { if(i == 1){ step = parseFloat(d.Time); } });
            CH2Data.forEach((d, i) => { if(i == CH2Data.length-1){ last = parseFloat(d.Time); } });
        }
        else if(frequencyCH1Value <= frequencyCH2Value && frequencyCH2Value < 5 * frequencyCH1Value){
            CH2Data.forEach((d, i) => { if(i == 1){ step = parseFloat(d.Time); } });
            CH1Data.forEach((d, i) => { if(i == CH1Data.length-1){ last = parseFloat(d.Time); } });
        }
        else{ 
            step = 0; 
            last = 0; 
            alert("The frequency of the signals is too different.");
            return;
        }
        let numPoints = Math.ceil(last / step) + 1;
        let mathData2 = [];
        mathData2[0] = ["Time", "Amplitude"];
        for (let i = 1; i <= numPoints; i++){
            let time = i * step;
            let CH1Value = interpulation(time, CH1Data);
            let CH2Value = interpulation(time, CH2Data);
            if(mathOperationValue == 0){ mathData2.push([time, CH1Value + CH2Value]); }
            else if(mathOperationValue == 1){ 
                if(mathOrderValue == 0){ mathData2.push([time, CH1Value - CH2Value]); }
                else if(mathOrderValue == 1){ mathData2.push([time, CH2Value - CH1Value]); }
            }
        }
        mathData = [];
        const keys2 = mathData2[0];
        for (let i = 1; i < mathData2.length-1; i++) {
            const values = mathData2[i];
            const object = {};
            keys2.forEach((key, index) => { object[key] = values[index]; });
            mathData.push(object);
        }

        showGraph3(mathData);
}

//? ------------------- Graph Drawing ------------------- //
function showGraph1(data) {
    if(mathDataFlag == 1){ showGraph3(mathData); }
    svg1 = d3.select('#myChart1');

    const width = 366;
    const height = 295;

    const horizontalScale = horizontalScaleList[horizontalScaleValue]*10;
    const verticalScale = verticalScaleList[verticalScaleValueCH1]*4;

    svg1.attr('width', width).attr('height', height);

    svg1.selectAll('*').remove();

    const xScale = d3.scaleLinear()
                     .domain([0, horizontalScale])
                     .range([0, width]);
    const yScale = d3.scaleLinear()
                     .domain([-verticalScale, verticalScale])
                     .range([height, 0]);
    const line = d3.line()
                    .x((d, i) => xScale(parseFloat(d.Time) + horizontalScale * (horizontalPositionValue + 0.5)  + timeTraveledCH1 + horizontalScale * distanceTraveledCH1))
                    .y(d => yScale((d.Amplitude + verticalScale*verticalPositionValueCH1) / (10 ** probeValueCH1)));

    let j = 0;
    let time;
    data.forEach(d => {
        j++;
        if(j == data.length){
            time = parseFloat(d.Time);
        }
    });
    const interval = time;
    for (let i = -numPeriods; i < numPeriods; i++) {
        const translatedData = data.map(d => ({ Time: parseFloat(d.Time) + i * interval, Amplitude: d.Amplitude }));
        svg1.append('path')
            .datum(translatedData)
            .attr('fill', 'none')
            .attr('stroke', 'rgb(255, 255, 40)')
            .attr('stroke-width', 2)
            .attr('d', line);
    }
}
function showGraph1Real(data) {
    if(mathDataFlag == 1){showGraph3(mathData);}
    svg1 = d3.select('#myChart1');

    const width = 366;
    const height = 295;

    const horizontalScale = horizontalScaleList[horizontalScaleValue]*10
    const verticalScale = verticalScaleList[verticalScaleValueCH1]*4
    svg1.attr('width', width).attr('height', height);

    svg1.selectAll('*').remove();
    
    const xScale = d3.scaleLinear()
                     .domain([0, horizontalScale])
                     .range([0, width]);
    const yScale = d3.scaleLinear()
                     .domain([-verticalScale, verticalScale])
                     .range([height, 0]);
    const line = d3.line()
                    .x((d, i) => xScale(parseFloat(d.Time)))
                    .y(d => yScale((d.Amplitude+ verticalScale*verticalPositionValueCH1) / (10 ** probeValueCH1)));

    let j = 0;
    let time;
    data.forEach(d => {
        j++;
        if(j == data.length){
            time = parseFloat(d.Time);
        }
    });
    const interval = time;
    for (let i = -numPeriods; i < numPeriods; i++) {
        const translatedData = data.map(d => ({ Time: parseFloat(d.Time) + i * interval, Amplitude: d.Amplitude }));
        svg1.append('path')
            .datum(translatedData)
            .attr('fill', 'none')
            .attr('stroke', 'rgb(255, 255, 40)')
            .attr('stroke-width', 2)
            .attr('d', line);
    }
}
function showGraph2(data) {
    if(mathDataFlag == 1){showGraph3(mathData);}
    svg2 = d3.select('#myChart2');

    const width = 366;
    const height = 295;

    const horizontalScale = horizontalScaleList[horizontalScaleValue]*10
    const verticalScale = verticalScaleList[verticalScaleValueCH2]*4
    svg2.attr('width', width).attr('height', height);

    svg2.selectAll('*').remove();

    const xScale = d3.scaleLinear()
                    .domain([0, horizontalScale])
                    .range([0, width]);
    const yScale = d3.scaleLinear()
                    .domain([-verticalScale, verticalScale])
                    .range([height, 0]);
    const line = d3.line()
                    .x((d, i) => xScale(parseFloat(d.Time) + horizontalScale * (horizontalPositionValue + 0.5)  + timeTraveledCH2  + horizontalScale * distanceTraveledCH2))
                    .y(d => yScale((d.Amplitude + verticalScale*verticalPositionValueCH2) / (10**probeValueCH2)));

    let j = 0;
    let time;
    data.forEach(d => {
        j++;
        if(j == data.length){
            time = parseFloat(d.Time);
        }
    });
    const interval = time;
    for (let i = -numPeriods; i < numPeriods; i++) {
        const translatedData = data.map(d => ({ Time: parseFloat(d.Time) + i * interval, Amplitude: d.Amplitude }));
        svg2.append('path')
            .datum(translatedData)
            .attr('fill', 'none')
            .attr('stroke', 'rgb(0, 242, 255)')
            .attr('stroke-width', 2)
            .attr('d', line);
    }
}
function showGraph2Real(data) {
    if(mathDataFlag == 1){showGraph3(mathData);}
    svg2 = d3.select('#myChart2');

    const width = 366;
    const height = 295;

    const horizontalScale = horizontalScaleList[horizontalScaleValue]*10
    const verticalScale = verticalScaleList[verticalScaleValueCH2]*4
    svg2.attr('width', width).attr('height', height);

    svg2.selectAll('*').remove();

    const xScale = d3.scaleLinear()
                    .domain([0, horizontalScale])
                    .range([0, width]);
    const yScale = d3.scaleLinear()
                    .domain([-verticalScale, verticalScale])
                    .range([height, 0]);
    const line = d3.line()
                    .x((d, i) => xScale(parseFloat(d.Time)))
                    .y(d => yScale((d.Amplitude + verticalScale*verticalPositionValueCH2) / (10**probeValueCH2)));

    let j = 0;
    let time;
    data.forEach(d => {
        j++;
        if(j == data.length){
            time = parseFloat(d.Time);
        }
    });
    const interval = time;
    for (let i = -numPeriods; i < numPeriods; i++) {
        const translatedData = data.map(d => ({ Time: parseFloat(d.Time) + i * interval, Amplitude: d.Amplitude }));
        svg2.append('path')
            .datum(translatedData)
            .attr('fill', 'none')
            .attr('stroke', 'rgb(0, 242, 255)')
            .attr('stroke-width', 2)
            .attr('d', line);
    }
}
function showGraph3(data) {
    svg3 = d3.select('#myChart3');

    const width = 366;
    const height = 295;

    const horizontalScale = horizontalScaleList[horizontalScaleValue]*10;
    let verticalScale;
    if(verticalScaleValueCH1 >= verticalScaleValueCH2){ verticalScale = verticalScaleList[verticalScaleValueCH1]*4; }
    else{ verticalScale = verticalScaleList[verticalScaleValueCH2]*4; }
    svg3.attr('width', width).attr('height', height);

    svg3.selectAll('*').remove();

    const xScale = d3.scaleLinear()
                    .domain([0, horizontalScale])
                    .range([0, width]);
    const yScale = d3.scaleLinear()
                    .domain([-verticalScale, verticalScale])
                    .range([height, 0]);
    const line = d3.line()
                    .x((d, i) => xScale(d.Time + horizontalScale * (horizontalPositionValue + 0.5)))
                    .y(d => yScale(d.Amplitude));

    let j = 0;
    let time;
    data.forEach(d => {
        j++;
        if(j == data.length){
            time = parseFloat(d.Time);
        }
    });
    const interval = time;
    for (let i = -numPeriods; i < numPeriods; i++) {
        const translatedData = data.map(d => ({ Time: parseFloat(d.Time) + i * interval, Amplitude: d.Amplitude }));
        svg3.append('path')
            .datum(translatedData)
            .attr('fill', 'none')
            .attr('stroke', 'rgb(255, 0, 0)')
            .attr('stroke-width', 2)
            .attr('d', line);
    }
}